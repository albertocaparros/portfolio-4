[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.2.5","content-config-digest","ab6a4560381b744b","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12,48,49],"frontend-guide",{"id":11,"data":13,"body":24,"filePath":25,"digest":26,"rendered":27,"legacyId":47},{"title":14,"pubDate":15,"description":16,"image":17,"href":11,"author":20,"tags":21},"Introducing the Why-First Approach to Frontend Development",["Date","2025-02-09T18:30:00.000Z"],"A new series of blog posts dedicated to exploring the reasons and motivations behind the most common frontend tools and practices.",{"url":18,"alt":19},"https://images.unsplash.com/photo-1472437774355-71ab6752b434?q=80&h=250","Frontend development books","Alberto Caparrós",[22,23],"introduction","why-first","![Frontend development books](https://images.unsplash.com/photo-1472437774355-71ab6752b434?q=80&h=250)\r\n\r\n# Introducing my approach to Frontend Development learning\r\n\r\nThis guide begins, as many things in life do, with a problem. I am searching for a new position in frontend development and preparing for the interviews ahead. It is hard *not* to be overwhelmed by the sheer amount of knowledge you *might* be asked about. \r\n\r\n> Routing, Responsive Web Design, Lazy loading, Accessibility, Optimization, SEO, Different Architectures, State Management, \u003Csmall>Data structures and algorights, Testing, Debugging, Memoization, CSS-in-JS, Change detection, Cookies & Storage, \u003Csub>Promises, Async/Await, Server-Side Rendering...\u003C/sub>\u003C/small>\r\n\r\nI think you get the idea.\r\n\r\nAnd that's just the *general* topics - never mind the specific details of the particular library or framework you'll be working with. Not only do I lack the time to prepare as thoroughly as I’d like, but I also don’t believe it should be necessary. Having worked in software engineering for a while, I know that at its core, our job is actually quite simple: our software’s clients have a problem, and we need to provide them with a solution.\r\n\r\n## But *Why*\r\n\r\nWe’re far enough along in software development that reinventing the wheel doesn’t make sense. The way we truly get better at our jobs is by improving our **understanding** of the problems, and by knowing **why** different solutions were created by talented engineers.\r\n\r\n- Why do we even need frontend development?\r\n- Why did React choose a Virtual DOM approach, and how does it solve performance and complexity issues?\r\n- Why does Vite exist if Webpack is already so popular?\r\n\r\nBy systematically uncovering the *problems* and *constraints* that gave birth to these solutions, we gain:\r\n\r\n1. *Deeper Understanding*: We can connect the dots between seemingly unrelated tools or techniques.  \r\n2. *Transferable Skills*: If you know why a solution exists, you can evaluate new tools more effectively and make better decisions.  \r\n3. *Better Interview Readiness*: You won't just parrot facts; you'll engage in *reasoning* about trade-offs and design considerations.\r\n\r\n## What to Expect Next\r\n\r\nIn upcoming posts, I’ll share a series of articles that trace frontend development from its broadest purpose (\"Why do we need web apps?\") down to specific questions (\"Why do custom hooks exist in React?\"). Each post will highlight the **problems** that prompted a particular solution, the **constraints** that shaped it, and the **benefits** it provides.\r\n\r\n---\r\n\r\n*Happy coding, and remember: always ask “why.”*","src/content/blog/frontend-guide.md","26911b987f0caf03",{"html":28,"metadata":29},"\u003Cp>\u003Cimg src=\"https://images.unsplash.com/photo-1472437774355-71ab6752b434?q=80&#x26;h=250\" alt=\"Frontend development books\">\u003C/p>\n\u003Ch1 id=\"introducing-my-approach-to-frontend-development-learning\">Introducing my approach to Frontend Development learning\u003C/h1>\n\u003Cp>This guide begins, as many things in life do, with a problem. I am searching for a new position in frontend development and preparing for the interviews ahead. It is hard \u003Cem>not\u003C/em> to be overwhelmed by the sheer amount of knowledge you \u003Cem>might\u003C/em> be asked about.\u003C/p>\n\u003Cblockquote>\n\u003Cp>Routing, Responsive Web Design, Lazy loading, Accessibility, Optimization, SEO, Different Architectures, State Management, \u003Csmall>Data structures and algorights, Testing, Debugging, Memoization, CSS-in-JS, Change detection, Cookies &#x26; Storage, \u003Csub>Promises, Async/Await, Server-Side Rendering…\u003C/sub>\u003C/small>\u003C/p>\n\u003C/blockquote>\n\u003Cp>I think you get the idea.\u003C/p>\n\u003Cp>And that’s just the \u003Cem>general\u003C/em> topics - never mind the specific details of the particular library or framework you’ll be working with. Not only do I lack the time to prepare as thoroughly as I’d like, but I also don’t believe it should be necessary. Having worked in software engineering for a while, I know that at its core, our job is actually quite simple: our software’s clients have a problem, and we need to provide them with a solution.\u003C/p>\n\u003Ch2 id=\"but-why\">But \u003Cem>Why\u003C/em>\u003C/h2>\n\u003Cp>We’re far enough along in software development that reinventing the wheel doesn’t make sense. The way we truly get better at our jobs is by improving our \u003Cstrong>understanding\u003C/strong> of the problems, and by knowing \u003Cstrong>why\u003C/strong> different solutions were created by talented engineers.\u003C/p>\n\u003Cul>\n\u003Cli>Why do we even need frontend development?\u003C/li>\n\u003Cli>Why did React choose a Virtual DOM approach, and how does it solve performance and complexity issues?\u003C/li>\n\u003Cli>Why does Vite exist if Webpack is already so popular?\u003C/li>\n\u003C/ul>\n\u003Cp>By systematically uncovering the \u003Cem>problems\u003C/em> and \u003Cem>constraints\u003C/em> that gave birth to these solutions, we gain:\u003C/p>\n\u003Col>\n\u003Cli>\u003Cem>Deeper Understanding\u003C/em>: We can connect the dots between seemingly unrelated tools or techniques.\u003C/li>\n\u003Cli>\u003Cem>Transferable Skills\u003C/em>: If you know why a solution exists, you can evaluate new tools more effectively and make better decisions.\u003C/li>\n\u003Cli>\u003Cem>Better Interview Readiness\u003C/em>: You won’t just parrot facts; you’ll engage in \u003Cem>reasoning\u003C/em> about trade-offs and design considerations.\u003C/li>\n\u003C/ol>\n\u003Ch2 id=\"what-to-expect-next\">What to Expect Next\u003C/h2>\n\u003Cp>In upcoming posts, I’ll share a series of articles that trace frontend development from its broadest purpose (“Why do we need web apps?”) down to specific questions (“Why do custom hooks exist in React?”). Each post will highlight the \u003Cstrong>problems\u003C/strong> that prompted a particular solution, the \u003Cstrong>constraints\u003C/strong> that shaped it, and the \u003Cstrong>benefits\u003C/strong> it provides.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cem>Happy coding, and remember: always ask “why.”\u003C/em>\u003C/p>",{"headings":30,"imagePaths":42,"frontmatter":43},[31,35,39],{"depth":32,"slug":33,"text":34},1,"introducing-my-approach-to-frontend-development-learning","Introducing my approach to Frontend Development learning",{"depth":36,"slug":37,"text":38},2,"but-why","But Why",{"depth":36,"slug":40,"text":41},"what-to-expect-next","What to Expect Next",[],{"author":20,"pubDate":44,"title":14,"href":11,"image":45,"tags":46,"description":16},["Date","2025-02-09T18:30:00.000Z"],{"url":18,"alt":19},[22,23],"frontend-guide.md","why-frontend",{"id":48,"data":50,"body":58,"filePath":59,"digest":60,"rendered":61,"legacyId":82},{"title":51,"pubDate":52,"description":53,"image":54,"href":11,"author":20,"tags":57},"Why Frontend development",["Date","2025-02-10T20:15:00.000Z"],"Let's go back to the basics, and try to understand how we ended up with this crazy ecosystem of frontend tools and techniques.",{"url":55,"alt":56},"https://images.unsplash.com/photo-1600132806608-231446b2e7af?q=80&h=250","Sketch of a website",[23],"![Sketch of a website](https://images.unsplash.com/photo-1600132806608-231446b2e7af?q=80&h=250)\n\n## The Rise of Rich Web Applications\n\nBefore major frontend frameworks emerged, most websites were built with server-rendered pages (using technologies like PHP, ASP.NET, or JSP). However, as applications like Gmail and Google Maps began offering rich, interactive experiences, it became clear that the traditional model was no longer sufficient.\n\nThe classic model required full-page reloads for every interaction, which disrupted user experience. Dynamic features (such as real-time updates or interactive maps) demanded smoother, more immediate interactions that server-only rendering couldn’t efficiently provide.\n\nThe introduction of AJAX allowed developers to fetch data asynchronously and update parts of a page without reloading the entire document. This shift pushed more logic to the browser, paving the way for a clear separation between frontend (UI/interaction) and backend (data processing, business logic).\n\n## Emergence of the Frontend-Backend Separation - Early Client Libraries\n\nAs the client side started handling more responsibilities, it became evident that managing increasingly complex interactions and state within the browser required more structure than ad hoc jQuery scripts or simple DOM manipulations. Code bases became difficult to maintain as interactivity increased, and it was challenging to keep the application state consistent. Especially when multiple parts of a page were interacting with each other asynchronously.\n\nThe growing complexity led to the early adoption of MVC (Model-View-Controller) or MVVM (Model-View-ViewModel) patterns on the client side. Frameworks such as Backbone.js and, eventually, AngularJS started to appear to address these needs. This era marked the clear separation between frontend and backend responsibilities. Frontend evolved into its own discipline, focused on delivering interactive, stateful user interfaces while the backend handled data persistence, business logic, and security.\n\n## Modern Frontend Frameworks: Consolidation and Evolution\n\nAs web applications grew even more complex, the demands on the client side led to the birth of robust frameworks that would not only manage interactivity but also simplify development at scale.\n\n- **Angular**:\nOriginating as AngularJS and later re-architected into Angular 2+, Google’s Angular introduced a comprehensive, opinionated framework. It came equipped with dependency injection, two-way data binding, and a complete suite of tools for testing and building enterprise-level applications. This approach offered a clear path for developers to handle large-scale projects with consistent patterns.\n\n- **React**:\nDeveloped by Facebook, React shifted the focus solely to the view layer. Its component-based architecture, virtual DOM, and one-way data flow provided a flexible and efficient way to build interactive user interfaces. React’s minimal core and the rich ecosystem that grew around it (such as Redux for state management) made it highly adaptable to various project needs.\n\n- **Vue**:\nVue emerged as a progressive framework that blended the strengths of both Angular and React. It offered an approachable learning curve, flexibility, and a set of integrated features ideal for building dynamic user interfaces. Vue’s scalability and simplicity have earned it a strong following among developers working on both small projects and large-scale applications.\n\n## Why This Evolution?\n\nAll three frameworks embraced a component-based model, which naturally arose from the need to manage complex, interactive interfaces. This paradigm promoted reusability, modularity, and easier maintenance.\n\nAs user interactions and dynamic data became more prevalent, managing application state efficiently and ensuring high performance were critical. Frameworks evolved to address these challenges, whether through built-in solutions (as in Angular) or via companion libraries (as in React).\n\nThe rise of these frameworks was also fueled by the strong communities and ecosystems that formed around them. This support network accelerated the development of tools, best practices, and learning resources, further solidifying their roles in modern web development.","src/content/blog/why-frontend.md","922fad33734f8db1",{"html":62,"metadata":63},"\u003Cp>\u003Cimg src=\"https://images.unsplash.com/photo-1600132806608-231446b2e7af?q=80&#x26;h=250\" alt=\"Sketch of a website\">\u003C/p>\n\u003Ch2 id=\"the-rise-of-rich-web-applications\">The Rise of Rich Web Applications\u003C/h2>\n\u003Cp>Before major frontend frameworks emerged, most websites were built with server-rendered pages (using technologies like PHP, ASP.NET, or JSP). However, as applications like Gmail and Google Maps began offering rich, interactive experiences, it became clear that the traditional model was no longer sufficient.\u003C/p>\n\u003Cp>The classic model required full-page reloads for every interaction, which disrupted user experience. Dynamic features (such as real-time updates or interactive maps) demanded smoother, more immediate interactions that server-only rendering couldn’t efficiently provide.\u003C/p>\n\u003Cp>The introduction of AJAX allowed developers to fetch data asynchronously and update parts of a page without reloading the entire document. This shift pushed more logic to the browser, paving the way for a clear separation between frontend (UI/interaction) and backend (data processing, business logic).\u003C/p>\n\u003Ch2 id=\"emergence-of-the-frontend-backend-separation---early-client-libraries\">Emergence of the Frontend-Backend Separation - Early Client Libraries\u003C/h2>\n\u003Cp>As the client side started handling more responsibilities, it became evident that managing increasingly complex interactions and state within the browser required more structure than ad hoc jQuery scripts or simple DOM manipulations. Code bases became difficult to maintain as interactivity increased, and it was challenging to keep the application state consistent. Especially when multiple parts of a page were interacting with each other asynchronously.\u003C/p>\n\u003Cp>The growing complexity led to the early adoption of MVC (Model-View-Controller) or MVVM (Model-View-ViewModel) patterns on the client side. Frameworks such as Backbone.js and, eventually, AngularJS started to appear to address these needs. This era marked the clear separation between frontend and backend responsibilities. Frontend evolved into its own discipline, focused on delivering interactive, stateful user interfaces while the backend handled data persistence, business logic, and security.\u003C/p>\n\u003Ch2 id=\"modern-frontend-frameworks-consolidation-and-evolution\">Modern Frontend Frameworks: Consolidation and Evolution\u003C/h2>\n\u003Cp>As web applications grew even more complex, the demands on the client side led to the birth of robust frameworks that would not only manage interactivity but also simplify development at scale.\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Angular\u003C/strong>:\nOriginating as AngularJS and later re-architected into Angular 2+, Google’s Angular introduced a comprehensive, opinionated framework. It came equipped with dependency injection, two-way data binding, and a complete suite of tools for testing and building enterprise-level applications. This approach offered a clear path for developers to handle large-scale projects with consistent patterns.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>React\u003C/strong>:\nDeveloped by Facebook, React shifted the focus solely to the view layer. Its component-based architecture, virtual DOM, and one-way data flow provided a flexible and efficient way to build interactive user interfaces. React’s minimal core and the rich ecosystem that grew around it (such as Redux for state management) made it highly adaptable to various project needs.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Vue\u003C/strong>:\nVue emerged as a progressive framework that blended the strengths of both Angular and React. It offered an approachable learning curve, flexibility, and a set of integrated features ideal for building dynamic user interfaces. Vue’s scalability and simplicity have earned it a strong following among developers working on both small projects and large-scale applications.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"why-this-evolution\">Why This Evolution?\u003C/h2>\n\u003Cp>All three frameworks embraced a component-based model, which naturally arose from the need to manage complex, interactive interfaces. This paradigm promoted reusability, modularity, and easier maintenance.\u003C/p>\n\u003Cp>As user interactions and dynamic data became more prevalent, managing application state efficiently and ensuring high performance were critical. Frameworks evolved to address these challenges, whether through built-in solutions (as in Angular) or via companion libraries (as in React).\u003C/p>\n\u003Cp>The rise of these frameworks was also fueled by the strong communities and ecosystems that formed around them. This support network accelerated the development of tools, best practices, and learning resources, further solidifying their roles in modern web development.\u003C/p>",{"headings":64,"imagePaths":77,"frontmatter":78},[65,68,71,74],{"depth":36,"slug":66,"text":67},"the-rise-of-rich-web-applications","The Rise of Rich Web Applications",{"depth":36,"slug":69,"text":70},"emergence-of-the-frontend-backend-separation---early-client-libraries","Emergence of the Frontend-Backend Separation - Early Client Libraries",{"depth":36,"slug":72,"text":73},"modern-frontend-frameworks-consolidation-and-evolution","Modern Frontend Frameworks: Consolidation and Evolution",{"depth":36,"slug":75,"text":76},"why-this-evolution","Why This Evolution?",[],{"author":20,"pubDate":79,"title":51,"href":11,"image":80,"tags":81,"description":53},["Date","2025-02-10T20:15:00.000Z"],{"url":55,"alt":56},[23],"why-frontend.md"]